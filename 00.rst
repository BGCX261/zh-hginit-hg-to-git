如果您以前接触过Subversion，Mercurial将会颠覆你对版本管理的认识，使你感觉很困惑。这篇教程将介绍Mercurial工作方式和 Subversion之间的区别。如果你没接触过Subversion，那就直接跳过这章吧。

==================
重新审视Subversion
==================

我们公司的一位程序员向我强烈建议用Mercurial替换掉 Subversion，此时我感觉很困惑。

最初，我提出了各种愚蠢的观点来拒绝。“我们应当把版本控制库放在一个中央服务器上，这样会更安全些” 。当然，在这个观点上我是彻底错误的。按照Mercurial的方式，每个开发人员都会在自己的硬盘上保存一份完整版本控制库。这实际上是更安全的一个做法。而且几乎每一个Mercurial项目组也都会有一个中央版本控制库。你可以对中央库进行强制备份，或者其他任何IT部门要求的操作。

“分布式版本控制的问题是太容易创建分支了，而分支是最容易出问题的”，这个观点同样是错误的。Subversion 的分支容易出问题，主要是Subversion没有提供足够多的信息来保证分支合并的正常工作。 在Mercurial里分支合并是一件很轻松惬意的事，所以分支的创建是一个普遍无害的操作。

最后我说“好吧，我会看看，但别指望我会真正去用使用”。我叫Jacob做了张列表。表里列出了常用的Subversion以及这些操作在Mercurial中的等效方法。

我不会给你看这个列表，这张列表让我迷糊了好几个月。

这件事说明，如果你以前用过subversion，那你的脑袋会有些转不过弯。你需要一些反思来更新自己的观念。在长达六个月的时间内，我一直认为Mercurial要比Subversion复杂得多。但事实上是我没有真正明白 Mercurial应该如何使用，一旦掌握了正确的使用方法后你会发现原来一切是如此的简单。

在这个教程里我将尽量不用 Subversion来做参照，因为这除了使你觉得头痛外没有任何意义。这个世界上让人头痛的事已经够多了。与之相反，对于Subversion的用户，我会要他们尽量忘记Subversion，把大脑清空以后再来学习Mercurial。

**如果你从来没有接触过Subversion，你可以直接跳到下一章节，你不会遗漏任何内容的。**

准备好了没？让我们来个简单的问答吧。

  **问题 1.** 你可以在第一遍的时候就写出完美的代码？

如果你的回答是 “Yes”，那你绝对是个骗子。

新写好的代码总是充满了bug。你需要花些时间调试后才可保证她的正常工作。在此期间，可能会影响团队内其他开发人员的工作。

这是Subversion的传统做法：

  * 在你check in代码的时候，每个开发人员都获取你新check in的代码。

你新写的代码中存在bug，你会有如下选择。

  * 你可以checkin有bug的代码，然后把所有人搞疯，或者
  * 在做好充分调试前不要进行checkin操作

Subversion 总是给你出这样的难题。要么库里的代码满是bug，要么新写的代码都放在本地。

作为Subversion的用户，我们早已对此习以为常。

使用Subversion时，组员们经常数天甚至数星期都不checkin任何东西。新手们总会担心在代码 check in后会导致程序无法编译。

因为害怕数周都不checkin代码，使版本控制无法发挥其应有的作用。最终他们还是需要有经验的开发人员来协助完成代码的checkin。如果你根本就不去用，那版本控制还有什么意义?

下面的图展示了Subversion是如何被使用的：

对于Mercurial，每个开发人员拥有自己本地的版本控制库：

只要你愿意，你可以随时提交提交代码到你的私人版本控制库。只要你的代码到达一定的逻辑点，你就可以将代码提交到版本控制库。

等到代码比较稳定后，你可以将你所做的代码改动push到中央版本控制库。在其他人在从中央版本控制库pulls代码的时候就可以看到你的代码了。

Mercurial将你提交的新代码和其他人的代码隔离出来。

这意味着你提交后 (hg com) 不会影响到其他人。等到你完成修改，代码稳定后你可以将改动push(hg push)到中央版本控制库。

一些理念上的主要分歧
--------------------

你知道街道是如何命名的吗？

好吧，我们用日本来举例，这样简单些。他们通常只给街道间的区域进行编号，只有非常非常重要的街道才会有自己的名字。

这就如Subversion和 Mercurial之间的区别。

Subversion 采用revisions的方式。 revision看起来就像是某个时间点整个文件系统的一个快照。

Mercurial 则采用changesets的方式. changeset是版本与版本之间变更情况的简明列表。

6和12/2有啥区别？

区别在这里。试想一下，我和你在修改同一份代码，我们分别建立的不同的分支并独立工作。期间我们都分别做了大量的改动。, so they have diverged quite a bit.

等到我们需要合并（merge）的时候的时候，Subversion尝试分别查看我们俩的改动版本，然后尝试将两个版本合并到一起。文件需要如何合并，多半是靠猜，所以失败也是很正常的。Subversion会给出大量的合并冲突（merge conflicts），而这些冲突并不是真正存在的，真正的问题是Subversion并没有搞清楚我们具体做了什么操作。

与之相对应，我们在各自使用Mercurial时，Mercurial频繁的维护一个changesets列表。 等到我们需要合并代码的时候Mercurial能够得到足够多的信息来用于合并。Mercurial会知道各个变更之间的关系，知道哪些改动是可以被覆盖的。

举个例子吧。等给给一个函数做了一些修改，然后将这个函数移动到其他地方。Subversion不会记录你的操作步骤，等到合并的时候，她会认为这是一个新的函数。 Mercurial则会分别记录函数修改和函数移动的操作。这意味着，如果你也同时对该函数做了修改，Mercurial更有可能成功的将我们俩的改动合并起来。

由于Mercurial会记录所有的changesets，你可以借此来做一些有趣的事情。你除了可以将代码 push到中央版本控制库外，你还可以将你的改动push给项目组中的指定成员。

或许你现在会感觉有些迷惑，不过不要担心，等你看完本教程后自然会有清楚的认识的。至于现在，你只要清楚Mercurial使用“changesets”来替换“revisions”，这使得代码合并方面比Subversion更要更加容易。

这意味着你可以随心所欲的进行分支，因为合并是不会变成一场噩梦。

想知道一些更有趣的事情？几乎每个我接触使用Subversion的项目组都同我谈起过类似的故事。这个故事实在是太过普遍，我把她命名为“Subversion故事#1”。故事如下：有时候我们为客户创建一个开发分支。这通常是一个不错的解决方案，但等到需要进行分支合并的时候，这一切演变成了一场噩梦。本是应是几分钟内完成的事情，最终让六个程序员花了两周来修复分支合并所产生的bug。

几乎每个Subversion团队都告诉我，他们再也不想经历一次类似的事情了，同时他们也不会再去用分支。现在的情况是，所有的新需求都写在一个巨大的 ifdef模块里。因此他们可以使用一个独立的trunk。在完成调试前，用户看不到任何新代码。坦率的说，这实在是一个非常可笑的做法。

将开发版本和稳定版本隔离开，正是版本控制库的建议做法之一。

当你切换到Mercurial，分支变得可行，你不必再为使用分支而感到忧虑。

这意味着你可以针对新需求创建一个开发团队内部的版本控制库。等到需求完成后，再将这个开发库合并到主版本控制库。

这意味着你可以创一个QA库。QA团队从QA库提取代码，等到代码检查没问题后再将代码push到中央库。这样保证了中央库里的代码总是经过严格测试过的。

这意味着你可以在各个独立的库中进行调试。如果代码工作正常，你可以将他们合并到主库。如果出现问题，你可以反复的修改他们，直到工作正常为止。

最后一个理念上的主要分歧
------------------------

Subversion 与Mercurial之间的这个分歧或许并不是很大不了的事。但如果你不了解他的话，很可能会因此栽跟头。问题是这样的：

Subversion 的版本控制是基于文件的。Mercurial的版本控制是将这个文件夹作为一个整体进行的—包括所有的子文件夹。

在 Subversion中你可以通过以下方法注意到这一点。你在子文件夹进行commit操作的时候，只会对当前文件夹和当前文件夹的所有子文件夹进行 commit操作，这样很可能导致你忘记将其他子文件夹的改动进行提交。Mercurial的所有命令都是对整体进行操作的。加入你的代码放在c:/code，不管你是在c:/code或是任何c:/code的子目录下执行hg commit命令，其效果都是相同的。

你或许习惯让整个公司共用一个巨无霸的版本控制库，然后让每个人在各自的目录下工作。这对Mercurial并不是一个合理的使用方式。你最好让每个项目都有自己独立的库。

最后…
-----

下面的话你就当我随便说说的吧。

Mercurial 比Subversion好更棒。

对个人和团队而言，这都是一个更有效的代码管理方式。
  
记住我的话，去理解Mercurial 的工作方式，以Mercurial的方式去使用Mercurial。不要尝试以Subversion的方式去使用Mercurial。总之，学会 Mercurial的方式，将会使你的工作边得愉快顺利。

在初期，你可能会感觉Mercurial很怪异，然后非常想抛弃 Mercurial，重返Subversion的怀抱，就如同思乡病犯了一样。然后你会找出各种各样的观点来支持自己把Mercurial抛弃。例如，Mercurial太费硬盘空间。事实上，这完全是个谬论，Mercurial比Subversion还更省空间。

然后你会继续走到Subversion的老路上去。你试图使用Subversion的方式去创建分支，但使你困惑的是，这似乎不太好用。在 Mercurial里分支的正确创建方式应当是clone一个新的库。不要尝试将Subversion里的经验套用到Mercurial。学习 Mercurial的工作方式，然后一切会变得美好。

然后你会找人给做张Subversion操作同Mercurial操作对照表。你会花费大量的时间去思考hg fetch同svn up的对应关系，却从来没有想过 hg fetch具体是做什么的。某一天，出问题了。你会责怪Mercurial，虽然真正应当责怪的是你并没有理解Mercurial的工作原理。

我想你会这么做，因为我当时就是这么做的。

不要再犯相同的错误了。学习Mercurial，信任Mercurial，找出适合Mercurial的工作方式 。你将为推动整个代码控制的发展进程做出贡献。当你的竞争对手们为了解决分支合并所带来的冲突忙得焦头烂额的时候，你输入 hg merge 然后高兴的说：“太棒了，顺利搞定”。一切其乐融融，生活多美好。
